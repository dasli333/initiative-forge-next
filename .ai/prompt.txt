Jako starszy programista frontendu Twoim zadaniem jest stworzenie szczegółowego planu wdrożenia nowego widoku w aplikacji internetowej. Plan ten powinien być kompleksowy i wystarczająco jasny dla innego programisty frontendowego, aby mógł poprawnie i wydajnie wdrożyć widok.

Najpierw przejrzyj następujące informacje:

1. Product Requirements Document (PRD):
<prd>
.ai/prd.md
</prd>

2. Opis widoku:
<view_description>
### 2.19. Session Prep View (World Building)

**Ścieżka**: `/campaigns/:id/sessions/prep/:sessionNumber`

**Główny cel**: Planowanie nadchodzącej sesji z goals, encounters, quick links do relevant NPCs/locations, prep checklist.

**Kluczowe informacje do wyświetlenia**:

- Session number i date
- Goals (rich text)
- Planned encounters (lista)
- Quick links (pinned entities)
- Prep checklist (TODO list)
- Notes (rich text)

**Kluczowe komponenty widoku**:

- **Header**:
  - Breadcrumb: "My Campaigns > [Campaign Name] > Sessions > Session #5 Prep"
  - H1: "Session #5 Prep"
  - Status Badge (draft/ready/in_progress)
  - Button "Mark as Ready"
- **Layout**: Single column, sections
- **Section 1: Basic Info**:
  - Session Number (display)
  - Session Date (real date picker)
  - In-Game Date (free text: "10 Hammer, 1492 DR")
  - Title (input: "Exploring Undermountain")
- **Section 2: Goals**:
  - H3: "Session Goals"
  - Tiptap Rich Text z @mentions
- **Section 3: Encounters**:
  - H3: "Planned Encounters"
  - Lista encounters (reorderable):
    - Type badge (story/combat)
    - Name (input)
    - Description (textarea)
    - Button "Remove"
  - Button "+ Add Encounter"
- **Section 4: Quick Links**:
  - H3: "Quick Access" (NPCs/Locations to introduce)
  - Grid pinned entities (drag to reorder):
    - Entity mini card: Type icon, Name, Quick preview (hover)
    - Button "X" remove pin
  - Button "+ Pin Entity" → command palette
- **Section 5: Prep Checklist**:
  - H3: "Prep Checklist"
  - Lista TODO items:
    - Checkbox, Text (input), Button "Remove"
  - Button "+ Add Item"
- **Section 6: Notes**:
  - H3: "Notes & Reminders"
  - Tiptap Rich Text z @mentions
- **Footer Actions**:
  - Button "Save Draft", Button "Mark as Ready", Button "Delete Session"

**UX, dostępność i względy bezpieczeństwa**:

- **UX**: Auto-save on blur, optimistic checklist toggle, drag to reorder encounters/pinned entities, command palette (Ctrl+K) dla pinning entities, status auto-update
- **Accessibility**: Checklist keyboard navigable, drag & drop keyboard alternative (move up/down buttons), ARIA live dla auto-save status
- **Security**: RLS per campaign, validation session_number unique

### 2.20. Session Journal View (World Building)

**Ścieżka**: `/campaigns/:id/sessions/journal/:sessionNumber`

**Główny cel**: Dokumentowanie zakończonej sesji z summary, key events, loot, XP, integration z timeline.

**Kluczowe informacje do wyświetlenia**:

- Session summary (rich text)
- Key events (lista, opcja add to timeline)
- Character decisions (rich text)
- Loot given (lista)
- XP given (number)
- Next session notes/cliffhanger (rich text)

**Kluczowe komponenty widoku**:

- **Header**:
  - Breadcrumb: "My Campaigns > [Campaign Name] > Sessions > Session #5 Journal"
  - H1: "Session #5 Journal"
  - Session Date display
- **Layout**: Single column, sections
- **Section 1: Summary**:
  - H3: "Session Summary"
  - Tiptap Rich Text z @mentions
- **Section 2: Key Events**:
  - H3: "Key Events"
  - Lista events:
    - Text (textarea)
    - Checkbox: "Add to Timeline"
    - Button "Remove"
  - Button "+ Add Event"
- **Section 3: Character Decisions**:
  - H3: "Character Decisions & Roleplay Moments"
  - Tiptap Rich Text z @mentions
- **Section 4: Rewards**:
  - H3: "Loot & Experience"
  - **Loot Given** (lista):
    - Item name (input), Button "Remove"
    - Button "+ Add Item"
  - **XP Given** (number input)
- **Section 5: Next Session**:
  - H3: "Next Session Notes / Cliffhanger"
  - Tiptap Rich Text z @mentions
- **Mentioned Entities Section** (auto z @mentions):
  - H3: "Entities Mentioned"
  - Grid entity badges (auto-generated z all @mentions w log)
- **Footer Actions**:
  - Button "Save Journal", Button "Mark Session as Completed"

**Note**: Przy "Mark as Completed", server auto-creates timeline events dla key events z `add_to_timeline === true`.

**UX, dostępność i względy bezpieczeństwa**:

- **UX**: Auto-save on blur, optimistic event add/remove, timeline integration visual feedback (badge change on checkbox), auto-extract @mentions, suggestion: "Add to timeline?" dla important events
- **Accessibility**: Dynamic list keyboard navigable, ARIA announcements dla timeline integration, focus management
- **Security**: RLS per campaign, validation XP/gold positive numbers, session must be "in_progress" or "completed" status

</view_description>

3. User Stories:
<user_stories>
#### ID: US-023

**Tytuł:** Przygotowanie nadchodzącej sesji

**Opis:** Jako DM, chcę przygotować plan nadchodzącej sesji z celami, encounters i quick links do relevant NPCs/locations, aby mieć wszystko pod ręką podczas gry.

**Kryteria akceptacji:**

- W widoku kampanii dostępna jest sekcja "Sessions" z zakładką "Prep".
- Formularz session plan zawiera pola: session number, session date (real date), in-game date (opcjonalnie), tytuł, cele sesji (rich text), planned encounters (lista z możliwością dodania story/combat encounters), prep checklist (TODO list), notes (rich text).
- Cele i notes obsługują rich text oraz @mentions.
- System pozwala na "pinning" entities (NPCs/locations/quests/items) do Quick Access Panel dla tej sesji.
- Przypięte entities są wyświetlane w panelu bocznym z miniaturowymi kartami.
- Status planu: Draft/Ready/In Progress/Completed.

#### ID: US-024

**Tytuł:** Dokumentowanie zakończonej sesji

**Opis:** Jako DM, po zakończonej sesji, chcę zapisać podsumowanie wydarzeń i kluczowych momentów, aby mieć historię kampanii do późniejszego przeglądu.

**Kryteria akceptacji:**

- W sekcji "Sessions" dostępna jest zakładka "Journal".
- Formularz session log zawiera pola: session number, session date (real date), in-game date (opcjonalnie), summary (rich text z @mentions), key events (lista wydarzeń), character decisions (rich text), loot given (structured list), XP given (liczba), next session notes/cliffhanger (rich text).
- Summary, character decisions i next session notes obsługują rich text oraz @mentions.
- System automatycznie śledzi wszystkie @mentioned entities w logu.
- Po zapisaniu loga, system sugeruje dodanie key events do Timeline.
- W karcie session log widoczna jest lista "Mentioned Entities" z linkami.
</user_stories>

4. Endpoint Description:
<endpoint_description>
### 2.16. Sessions

**Architecture Note**: Combined table for session prep (`plan_json`) and journal (`log_json`). Session number unique per campaign. Status: draft/ready/in_progress/completed.

#### List Campaign Sessions

- **Method**: GET
- **Path**: `/api/campaigns/:campaignId/sessions`
- **Query Parameters**:
  - `status` (optional, string): Filter by status
  - `limit/offset`: Pagination
- **Response**: 200 OK

```json
{
  "sessions": [
    {
      "id": "uuid",
      "campaign_id": "uuid",
      "session_number": 5,
      "session_date": "2025-01-20",
      "in_game_date": "10 Hammer, 1492 DR",
      "title": "Exploring Undermountain",
      "plan_json": {
        "goals": { "type": "doc", "content": [...] },
        "encounters": [...],
        "npcs_to_introduce": ["npc-uuid-1", "npc-uuid-2"],
        "locations_to_visit": ["loc-uuid-1"],
        "plot_points": [...],
        "prep_checklist": [
          { "text": "Print dungeon map", "completed": true }
        ],
        "notes": { "type": "doc", "content": [...] }
      },
      "log_json": null,
      "status": "ready",
      "created_at": "...",
      "updated_at": "..."
    }
  ],
  "total": 1
}
```

#### Create Session

- **Method**: POST
- **Path**: `/api/campaigns/:campaignId/sessions`
- **Request Body**:

```json
{
  "session_number": 6,
  "session_date": "2025-01-27",
  "in_game_date": "15 Hammer, 1492 DR",
  "title": "The Dragon's Lair",
  "plan_json": {...},
  "status": "draft"
}
```

- **Response**: 201 Created
- **Error Responses**:
  - 409 Conflict: Session number already exists in campaign

#### Get Session

- **Method**: GET
- **Path**: `/api/campaigns/:campaignId/sessions/:id`
- **Query Parameters**:
  - `include` (optional, string[]): Additional data ("mentioned_entities")
- **Response**: 200 OK (full session object)

#### Update Session

- **Method**: PATCH
- **Path**: `/api/campaigns/:campaignId/sessions/:id`
- **Description**: Updates session fields, including adding journal after session
- **Request Body**: (partial update)

```json
{
  "status": "completed",
  "log_json": {
    "summary": { "type": "doc", "content": [...] },
    "key_events": [
      { "text": "Party defeated the dragon", "add_to_timeline": true }
    ],
    "character_decisions": { "type": "doc", "content": [...] },
    "loot_given": ["+1 Longsword", "500 gold"],
    "xp_given": 2000,
    "next_session_notes": { "type": "doc", "content": [...] }
  },
  "mentions": [...]
}
```

- **Response**: 200 OK

**Note**: When `key_events[].add_to_timeline === true`, server auto-creates timeline events linked to this session.

#### Delete Session

- **Method**: DELETE
- **Path**: `/api/campaigns/:campaignId/sessions/:id`
- **Response**: 204 No Content
</endpoint_description>

5. Endpoint Implementation:
<endpoint_implementation>
src/lib/api/sessions.ts
</endpoint_implementation>

6. Type Definitions:
<type_definitions>
src/types/sessions.ts
</type_definitions>

7. Tech Stack:
<tech_stack>
.ai/tech-stack.md
</tech_stack>

Przed utworzeniem ostatecznego planu wdrożenia przeprowadź analizę i planowanie wewnątrz tagów <implementation_breakdown> w swoim bloku myślenia. Ta sekcja może być dość długa, ponieważ ważne jest, aby być dokładnym.

W swoim podziale implementacji wykonaj następujące kroki:
1. Dla każdej sekcji wejściowej (PRD, User Stories, Endpoint Description, Endpoint Implementation, Type Definitions, Tech Stack):
  - Podsumuj kluczowe punkty
 - Wymień wszelkie wymagania lub ograniczenia
 - Zwróć uwagę na wszelkie potencjalne wyzwania lub ważne kwestie
2. Wyodrębnienie i wypisanie kluczowych wymagań z PRD
3. Wypisanie wszystkich potrzebnych głównych komponentów, wraz z krótkim opisem ich opisu, potrzebnych typów, obsługiwanych zdarzeń i warunków walidacji
4. Stworzenie wysokopoziomowego diagramu drzewa komponentów
5. Zidentyfikuj wymagane DTO i niestandardowe typy ViewModel dla każdego komponentu widoku. Szczegółowo wyjaśnij te nowe typy, dzieląc ich pola i powiązane typy.
6. Zidentyfikuj potencjalne zmienne stanu i niestandardowe hooki, wyjaśniając ich cel i sposób ich użycia
7. Wymień wymagane wywołania API i odpowiadające im akcje frontendowe
8. Zmapuj każdej historii użytkownika do konkretnych szczegółów implementacji, komponentów lub funkcji
9. Wymień interakcje użytkownika i ich oczekiwane wyniki
10. Wymień warunki wymagane przez API i jak je weryfikować na poziomie komponentów
11. Zidentyfikuj potencjalne scenariusze błędów i zasugeruj, jak sobie z nimi poradzić
12. Wymień potencjalne wyzwania związane z wdrożeniem tego widoku i zasugeruj możliwe rozwiązania

Po przeprowadzeniu analizy dostarcz plan wdrożenia w formacie Markdown z następującymi sekcjami:

1. Przegląd: Krótkie podsumowanie widoku i jego celu.
2. Routing widoku: Określenie ścieżki, na której widok powinien być dostępny.
3. Struktura komponentów: Zarys głównych komponentów i ich hierarchii.
4. Szczegóły komponentu: Dla każdego komponentu należy opisać:
 - Opis komponentu, jego przeznaczenie i z czego się składa
 - Główne elementy HTML i komponenty dzieci, które budują komponent
 - Obsługiwane zdarzenia
 - Warunki walidacji (szczegółowe warunki, zgodnie z API)
 - Typy (DTO i ViewModel) wymagane przez komponent
 - Propsy, które komponent przyjmuje od rodzica (interfejs komponentu)
5. Typy: Szczegółowy opis typów wymaganych do implementacji widoku, w tym dokładny podział wszelkich nowych typów lub modeli widoku według pól i typów.
6. Zarządzanie stanem: Szczegółowy opis sposobu zarządzania stanem w widoku, określenie, czy wymagany jest customowy hook.
7. Integracja API: Wyjaśnienie sposobu integracji z dostarczonym punktem końcowym. Precyzyjnie wskazuje typy żądania i odpowiedzi.
8. Interakcje użytkownika: Szczegółowy opis interakcji użytkownika i sposobu ich obsługi.
9. Warunki i walidacja: Opisz jakie warunki są weryfikowane przez interfejs, których komponentów dotyczą i jak wpływają one na stan interfejsu
10. Obsługa błędów: Opis sposobu obsługi potencjalnych błędów lub przypadków brzegowych.
11. Kroki implementacji: Przewodnik krok po kroku dotyczący implementacji widoku.

Upewnij się, że Twój plan jest zgodny z PRD, historyjkami użytkownika i uwzględnia dostarczony stack technologiczny.

Ostateczne wyniki powinny być w języku polskim i zapisane w pliku o nazwie .ai/{view-name}-view-implementation-plan.md. Nie uwzględniaj żadnej analizy i planowania w końcowym wyniku.

Oto przykład tego, jak powinien wyglądać plik wyjściowy (treść jest do zastąpienia):

```markdown
# Plan implementacji widoku [Nazwa widoku]

## 1. Przegląd
[Krótki opis widoku i jego celu]

## 2. Routing widoku
[Ścieżka, na której widok powinien być dostępny]

## 3. Struktura komponentów
[Zarys głównych komponentów i ich hierarchii]

## 4. Szczegóły komponentów
### [Nazwa komponentu 1]
- Opis komponentu [opis]
- Główne elementy: [opis]
- Obsługiwane interakcje: [lista]
- Obsługiwana walidacja: [lista, szczegółowa]
- Typy: [lista]
- Propsy: [lista]

### [Nazwa komponentu 2]
[...]

## 5. Typy
[Szczegółowy opis wymaganych typów]

## 6. Zarządzanie stanem
[Opis zarządzania stanem w widoku]

## 7. Integracja API
[Wyjaśnienie integracji z dostarczonym endpointem, wskazanie typów żądania i odpowiedzi]

## 8. Interakcje użytkownika
[Szczegółowy opis interakcji użytkownika]

## 9. Warunki i walidacja
[Szczegółowy opis warunków i ich walidacji]

## 10. Obsługa błędów
[Opis obsługi potencjalnych błędów]

## 11. Kroki implementacji
1. [Krok 1]
2. [Krok 2]
3. [...]
```

Rozpocznij analizę i planowanie już teraz. Twój ostateczny wynik powinien składać się wyłącznie z planu wdrożenia w języku polskim w formacie markdown, który zapiszesz w pliku .ai/ui-plans/sessions-view-implementation-plan.md i nie powinien powielać ani powtarzać żadnej pracy wykonanej w podziale implementacji.